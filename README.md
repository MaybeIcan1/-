# 第一章.双指针
## ①快慢指针
快慢指针就是两个指针朝着同一个方向动，只是有一个会一直走在前面。常用于解决：原地删除数组重复元素（LeetCode T26）、在原数组剔除某元素（T27）、删除排列链表某元素（T83）  
T26：  
T27：  
T83：  
另一大类是滑动窗口：  

## ②左右指针  
左右指针就是从某位置出发，两个指针朝着相反的方向运动（**有相对而行和相向而行两种！**）。  常用于：二分查找、寻找两数之和（T167）、反转数组（T344）、寻找回文（T5）  
2025.5.8日：  
### 寻找最长回文子串  
此题核心在于确定回文子串的函数的实现，由于回文子串分两种情况：  ①奇数子串：aba、acbca这种；②偶数子串：aabb、bb这种。  而回文子串的特点是每个元素关于中点对称，或者说满足s[l]==s[r]，l和r距离子串中心字符距离一样。因此，回文串就分为有一个字符中心（奇数串）和两个字符中心（偶数串）的情况  
所以判断是否为回文子串的函数可以如此：  
```c++
// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串
std::string palindrome(std::string s, int l, int r) {
    // 防止索引越界
    while (l >= 0 && r < s.length()
            && s[l] == s[r]) {
        // 双指针，向两边展开
        l--; r++;
    }
    // 此时 [l+1, r-1] 就是最长回文串
    return s.substr(l + 1, r-l-1);
}
```
而因为是要找最大的子串，肯定要遍历每一个原字符串s的回文子串，假如定义一个res来存放最大回文子串，那么在每一次找到一个回文子串时，有三个变量要进行比较：res、一个字符中心的回文子串s1、两个字符中心的回文子串s2，因此要用到三目运算符：A > B ? A : B  具体实现如下：  
```c++
string longestPalindrome(string s) {
        string res = "";
        for (int i = 0; i < s.length(); i++) {
            // 以 s[i] 为中心的最长回文子串
            string s1 = palindrome(s, i, i);
            // 以 s[i] 和 s[i+1] 为中心的最长回文子串
            string s2 = palindrome(s, i, i + 1);
            // res = longest(res, s1, s2)
            res = res.length() > s1.length() ? res : s1;
            res = res.length() > s2.length() ? res : s2;
        }
        return res;
    }
```
